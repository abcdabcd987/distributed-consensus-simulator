"""
    Sleepy Consensus Algorithms
    * Block class
        * pbhv : Hashval (string)
            the hash value of previous block (generated by hashlib)
        * txs  : Tx list (string list) 
            recorded transactions (input)
        * timestamp  : Timestamp (int)
            timestamp, indicating its t-th round
        * nid  : NodeId (int)
            node's identifier
        @ property
        * hashval(self) -> Hashval (string)
    * TNode class 
        we use tree to keep tract of main chain and alternative chains,
        TNode class represent node of the tree
        * block : Block
        * hv : Hashval (string) 
            the hash value of block in this node
            (store it so as to make searching blocks easier)
        * depth : int 
            the depth from this node to root
            (namely, the height of this block)
        * and something else to organize this structure
    * BlockChain class
        * __init__(self) -> None
            remember to add genesis block as the root of the tree
            pbhv = "0", txs = [], timestamp = 0, nid = 0
        * find(self, hash_val) -> TNode
            find the node that contain a block with specified hash value
        * add_child(self, t_node, block) -> TNode
            Create a new node with block inside and make it the t_node's child,
            and then return this node.
            This method will automatically check the depth of newly inserted node
            and update the main chain if needed
        @ property
        * main_chain(self) -> List[block]
            extract the main chain and form a list where every block just follows its father in the list
    * CheckSolution(block : Block class) -> bool
        Check if H(pid, t) < D_p
    * CheckTx(tx : Tx) -> bool
        placeholder, simply return True now
        Check if transaction is valid
    * TxPool class
        Store transactions that will be added into block
        * FindTx(self, tx) -> 
            check if a specifix transaction is already in it
        * AddTx(self, tx) -> bool
            add a transaction into pool if 
        * RemoveTx(self, tx) 
            remove a specific transaction
        * PopOne(self) : placeholder now
            pop the transaction with highest priority
        * PopAll(self) : 
            pop out all transaction
    * OrphanBlockPool class
        Store blocks whose parent block is not in the chain currently
        * AddBlock(self)
        * PopChild(self, hv) : 
            find the node with specified pbhv, if no match, return none
    * SignMessage(message, priv_key) -> signedMessage : placeholder
        use priv_key to sign message
"""

import hashlib
import string
# import rsa
import random
from typing import *
from dcsim.framework import *

D_p = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"  # 这个值暂时定为这么多，后面会改

Tx = string
Hashval = string
Timestamp = int
NodeId = int


# tx pool 存收到但没有放进去的交易信息
class TxPool:

    def __init__(self):
        self.transaction = []

    def add_tx(self, transaction) -> Tx:
        self.transaction.append(transaction)
        return transaction

    def remove_tx(self, transaction) -> bool:
        for item in self.transaction:
            if transaction == item:
                self.transaction.remove(transaction)
                return True
        return False

    def find_tx(self, transaction) -> Optional['Tx']:
        for item in self.transaction:
            if transaction == item:
                return transaction
        return None

    def pop_all(self):  # get data
        return self.transaction


class TBlock:

    def __init__(self, pbhv, transaction, timestamp, pid):
        # comes from TxPool
        self.transaction = transaction  # type: List[string]
        # father's hash, string
        self.pbhv = pbhv  # type: Hashval
        self.timestamp = timestamp  # type: Timestamp
        self.pid = pid  # type: NodeId

    @property
    def hashval(self) -> Hashval:  # get its own hash
        hashstr = "".join(self.transaction) + str(self.timestamp) + str(self.pid)
        return hashlib.sha256(hashstr.encode("utf-8")).hexdigest()

    def get_data(self) -> List[Tx]:
        return self.transaction


class TNode:

    def __init__(self, depth, block, father):  # father's(block's) hash
        self.depth = depth  # type: int
        self.block = block  # type: TBlock
        # own hash
        self.hash = block.get_hash()  # type: string
        self.father = father  # type: TNode

        self.index = []  # type: List[int]
        self.children = []  # type: List[TNode]
        self.num = 0  # type: int

    def get_children(self):
        return self.children

    def add_children(self, newnode: 'TNode') -> bool:
        # if full, max is 16
        if len(self.children) == 16:
            return False
        else:
            self.children.append(newnode)
            self.index.append(self.num)
            self.num += 1
            newnode.depth = self.depth + 1
            newnode.father = self
            return True

    def transfer_chain(self, i: int, j: int):
        x = self.index[i]
        self.index[i] = self.index[j]
        self.index[j] = x

    def search(self, phash) -> Optional['TNode']:
        res = None  # type: Union[TNode, None]
        for child in self.children:
            if child.hash == phash:
                return child
            else:
                res = child.search(phash)
                if res is not None:
                    break
        return res


class OrphanBlockPool:

    def __init__(self):
        self.block = []

    def add_block(self, ablock):
        self.block.append(ablock)

    def pop_child(self, hv) -> Optional['TBlock']:
        for i in self.block:
            if i.pbhv == hv:
                return i
        return None


def check_tx(tx: Tx):
    return True if tx is not None else False


def check_solution(tblock: TBlock):
    spid = '%s' % tblock.pid
    st = '%s' % tblock.timestamp
    sha256 = hashlib.sha256()
    k = spid + st
    sha256.update(k.encode('utf-8'))
    v = sha256.hexdigest()
    if v < D_p:
        return True
    else:
        return False

Message = Any
SignedMessage = Message


def sign_message(message: Message, priv_key) -> SignedMessage:
    return message if priv_key is not None else message


class HonestNode(NodeBase):

    def __init__(self, coorindator):
        # coordinator provides the "permissioned" services
        self._coorindator = coorindator
        # codes to generate rsa key pair, not used yet
        # (self.pub_key, self.priv_key) = rsa.newkeys(512)

        random.seed()
        self._nodeId = random.randint(1, 2**32)
        self._txpool = TxPool()
        self._orphanpool = OrphanBlockPool()

        raise NotImplemented
        self._block_chain = BlockChain()

    @property
    def id(self) -> NodeId:
        return self._nodeId

    @property
    def main_chain(self):
        raise NotImplemented
        return self._block_chain.main_chain

    def round_action(self, ctx: Context) -> None:
        # check recieved blocks
        messages: List[Any] = ctx.received_messages
        txs: List[Tx] = []
        blocks: List[TBlock] = []

        for message in messages:
            if message.type == 0:   # its a transaction
                if check_tx(message["value"]):
                    txs.append(message["value"])
            elif message.type == 1:   # its a block
                if not check_solution(message["value"]):
                    continue
                elif message["value"].timestamp >= ctx.round:
                    continue
                else:
                    blocks.append(message["value"])

        for block in blocks:
            # check block type : extend main chain, extend alternative chain, orphan block
            ctx.broadcast(block)

            raise NotImplemented
            child_block = block
            cur_node = self_block_chain.find(block.pbhv)
            while (cur_node is not None) and (cur_node.block.timestamp < block.timestamp):
                cur_node = self._block_chain.add_child(cur_node, child_block)
                child_block = self._orphanpool.pop_child(child_block.hashval)
            else:
                self._orphanpool.add(block)

        raise NotImplemented
