"""
    Sleepy Consensus Algorithms
    * Block class
        * pbhv : Hashval (string)
            the hash value of previous block (generated by hashlib)
        * txs  : Tx list (string list) 
            recorded transactions (input)
        * timestamp  : Timestamp (int)
            timestamp, indicating its t-th round
        * nid  : NodeId (int)
            node's identifier
        * function GetHash(self) -> Hashval (string)
    * TNode class 
        we use tree to keep tract of main chain and alternative chains,
        TNode class represent node of the tree
        * block : Block
        * hv : Hashval (string) 
            the hash value of block in this node
            (store it so as to make searching blocks easier)
        * depth : int 
            the depth from this node to root
            (namely, the height of this block)
        * and something else to organize this structure
    * BlockChain class
        implemented as a tree
    * CheckSolution(block : Block class) -> bool
        Check if H(pid, t) < D_p
    * CheckTx(tx : Tx) -> bool
        placeholder, simply return True now
        Check if transaction is valid
    * TxPool class
        Store transactions that will be added into block
        * FindTx(self, tx) -> 
            check if a specifix transaction is already in it
        * AddTx(self, tx) -> bool
            add a transaction into pool if 
        * RemoveTx(self, tx) 
            remove a specific transaction
        * PopOne(self) : placeholder now
            pop the transaction with highest priority
        * PopAll(self) : 
            pop out all transaction
    * OrphanBlockPool class
        Store blocks whose parent block is not in the chain currently
        * AddBlock(self)
        * PopChild(self, hv) : 
            find the node with specified pbhv, if no match, return none
    * SignMessage(message, priv_key) -> signedMessage : placeholder
        use priv_key to sign message
"""

import hashlib
import string
import rsa
from typing import *
from dcsim.framework import *

D_p = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"  # 这个值暂时定为这么多，后面会改

class tx:

    def __init__ (self, data):
        self.data = data

    def get_data(self) -> string:
        return self.data

# tx pool 存收到但没有放进去
class TxPool:

    def __init__ (self):
        self.transaction = []

    def AddTx(self, transaction) -> tx:
        self.transaction.append(transaction)
        return transaction

    def RemoveTx(self, transaction) -> bool:
        for item in self.transaction:
            if (transaction == item):
                self.transaction.remove(transaction)
                return True
        return False

    def FindTx(self, transaction) -> Optional['tx']:
        for item in self.transaction:
            if (transaction == item):
                return transaction
        return None

    def PopAll(self): # get data
        return self.transaction


class TBlock:

    def __init__ (self, pbhv, transaction, timestamp, pid):
        # comes from TxPool
        self.transaction = transaction # type: List[string]
        # father's hash, string
        self.pbhv = pbhv # type: string
        self.timestamp = timestamp # type: int
        self.pid = pid # type: int

    def get_hash(self) -> string: # get its own hash

        hashstr = "".join(self.transaction) + str(self.timestamp) + str(self.pid)
        return hashlib.sha256(hashstr.encode("utf-8")).hexdigest()

    def get_data(self) -> List[string]:
        return self.transaction

class TNode:

    def __init__ (self, depth, block, father): # father's(block's) hash
        self.depth = depth # type: int
        self.block = block # type: TBlock
        # own hash
        self.hash = block.get_hash() # type: string
        self.father = father # type: TNode

        self.index = [] # type: List[int]
        self.children = [] # type: List[TNode]
        self.num = 0 # type: int

    def get_children(self):
        return self.children

    def add_children(self, newnode : 'TNode') -> bool:
        # if full, max is 16
        if len(self.children) == 16:
            return False
        else:
            self.children.append(newnode)
            self.index.append(self.num)
            self.num += 1
            newnode.depth = self.depth + 1
            newnode.father = self
            return True

    def transfer_chain(self, i : int, j : int):
        x = self.index[i]
        self.index[i] = self.index[j]
        self.index[j] = x

    def search(self, phash) -> Optional['TNode']:
        res = None # type: Union[TNode, None]
        for child in self.children:
            if (child.hash == phash):
                return child
            else:
                res = child.search(phash)
                if (None != res):
                    break
        return res


class OrphanBlockPool:

    def __init__ (self):
        self.block = []

    def AddBlock(self, ablock):
        self.block.append(ablock)

    def PopChild(self, hv) -> Optional['TBlock']:
        for i in self.block:
            if (i.pbhv == hv):
                return i
        return None

Hashval = string
Tx = string
Timestamp = int
NodeId = int
Message = TBlock
SignedMessage = Message

def CheckTX(transaction : tx):
    return True

def CheckSolution(tblock : TBlock):
    spid = '%s' % tblock.pid
    st = '%s' % tblock.timestamp
    sha256 = hashlib.sha256()
    k = spid + st
    sha256.update(k.encode('utf-8'))
    v = sha256.hexdigest()
    if v < D_p:
        return True
    else:
        return False

def SignMessage(message : Message, priv_key) -> SignedMessage :
    return message

class HonestNode(NodeBase) :

    def __init__(self, coorindator):
        # coordinator provides the "permissioned" services
        self._coorindator = coorindator
        # codes to generate rsa key pair, not used yet
        # (self.pub_key, self.priv_key) = rsa.newkeys(512)

        # nodeId needs to be initialize by parameter passed by framework
        self._nodeId = len(self._coorindator.nodes)
        self._txpool = TxPool()
        self._orphanpool = OrphanBlockPool()

        raise NotImplemented
        self._block_chain = BlockChain()

    @property
    def id(self) -> NodeId :
        return self._nodeId

    def round_action(self, ctx: Context) -> None :
        # check input, not yet implement
        # inputs : List['string'] = ctx.received_inputs
        # for tx in inputs :
        #     self._txPool.AddTx(tx)

        # check recieved blocks
        blocks : List['TBlock'] = ctx.received_messages
        for block in blocks :
            if not CheckSolution(block) :
                blocks.remove(block)

        # check t

        raise NotImplemented
