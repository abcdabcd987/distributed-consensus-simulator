"""
    Sleepy Consensus Algorithms
    * Block class
        * pbhv : Hashval (string)
            the hash value of previous block (generated by hashlib)
        * txs  : Tx list (string list) 
            recorded transactions (input)
        * timestamp  : Timestamp (int)
            timestamp, indicating its t-th round
        * nid  : NodeId (int)
            node's identifier
        * function GetHash(self) -> Hashval (string)
    * TNode class 
        we use tree to keep tract of main chain and alternative chains,
        TNode class represent node of the tree
        * block : Block
        * hv : Hashval (string) 
            the hash value of block in this node
            (store it so as to make searching blocks easier)
        * depth : int 
            the depth from this node to root
            (namely, the height of this block)
        * and something else to organize this structure
    * BlockChain class
        * __init__(self) -> None
            remember to add genesis block as the root of the tree
            pbhv = "0", txs = [], timestamp = 0, nid = 0
        * find(self, hash_val) -> TNode
            find the node that contain a block with specified hash value
        * add_child(self, t_node, block) -> None
            Create a new node with block inside and make it the t_node's child.
            This method will automatically check the depth of newly inserted node
            and update the main chain if needed
        @ property
        * main_chain(self) -> List[block]
            extract the main chain and form a list where every block just follows its father in the list
    * CheckSolution(block : Block class) -> bool
        Check if H(pid, t) < D_p
    * CheckTx(tx : Tx) -> bool
        placeholder, simply return True now
        Check if transaction is valid
    * TxPool class
        Store transactions that will be added into block
        * FindTx(self, tx) -> 
            check if a specifix transaction is already in it
        * AddTx(self, tx) -> bool
            add a transaction into pool if 
        * RemoveTx(self, tx) 
            remove a specific transaction
        * PopOne(self) : placeholder now
            pop the transaction with highest priority
        * PopAll(self) : 
            pop out all transaction
    * OrphanBlockPool class
        Store blocks whose parent block is not in the chain currently
        * AddBlock(self)
        * PopChild(self, hv) : 
            find the node with specified pbhv, if no match, return none
    * SignMessage(message, priv_key) -> signedMessage : placeholder
        use priv_key to sign message
"""

import hashlib
import string
# import rsa
import secrets
from typing import *
from dcsim.framework import *

D_p = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"  # 这个值暂时定为这么多，后面会改

Tx = string


# tx pool 存收到但没有放进去的交易信息
class TxPool:

    def __init__(self):
        self.transaction = []

    def add_tx(self, transaction) -> Tx:
        self.transaction.append(transaction)
        return transaction

    def remove_tx(self, transaction) -> bool:
        for item in self.transaction:
            if transaction == item:
                self.transaction.remove(transaction)
                return True
        return False

    def find_tx(self, transaction) -> Optional['Tx']:
        for item in self.transaction:
            if transaction == item:
                return transaction
        return None

    def pop_all(self):  # get data
        return self.transaction


class TBlock:

    def __init__(self, pbhv, transaction, timestamp, pid):
        # comes from TxPool
        self.transaction = transaction  # type: List[string]
        # father's hash, string
        self.pbhv = pbhv  # type: string
        self.timestamp = timestamp  # type: int
        self.pid = pid  # type: int

    def get_hash(self) -> string:  # get its own hash

        hashstr = "".join(self.transaction) + str(self.timestamp) + str(self.pid)
        return hashlib.sha256(hashstr.encode("utf-8")).hexdigest()

    def get_data(self) -> List[string]:
        return self.transaction


class TNode:

    def __init__(self, depth, block, father):  # father's(block's) hash
        self.depth = depth  # type: int
        self.block = block  # type: TBlock
        # own hash
        self.hash = block.get_hash()  # type: string
        self.father = father  # type: TNode

        self.index = []  # type: List[int]
        self.children = []  # type: List[TNode]
        self.num = 0  # type: int

    def get_children(self):
        return self.children

    def add_children(self, newnode : 'TNode') -> bool:
        # if full, max is 16
        if len(self.children) == 16:
            return False
        else:
            self.children.append(newnode)
            self.index.append(self.num)
            self.num += 1
            newnode.depth = self.depth + 1
            newnode.father = self
            return True

    def transfer_chain(self, i : int, j : int):
        x = self.index[i]
        self.index[i] = self.index[j]
        self.index[j] = x

    def search(self, phash) -> Optional['TNode']:
        res = None # type: Union[TNode, None]
        for child in self.children:
            if (child.hash == phash):
                return child
            else:
                res = child.search(phash)
                if (None != res):
                    break
        return res


class OrphanBlockPool:

    def __init__ (self):
        self.block = []

    def add_block(self, ablock):
        self.block.append(ablock)

    def pop_child(self, hv) -> Optional['TBlock']:
        for i in self.block:
            if (i.pbhv == hv):
                return i
        return None

Hashval = string
Timestamp = int
NodeId = int
Message = Any
SignedMessage = Message

def check_tx(transaction : Tx):
    return True

def check_solution(tblock : TBlock):
    spid = '%s' % tblock.pid
    st = '%s' % tblock.timestamp
    sha256 = hashlib.sha256()
    k = spid + st
    sha256.update(k.encode('utf-8'))
    v = sha256.hexdigest()
    if v < D_p:
        return True
    else:
        return False

def sign_message(message : Message, priv_key) -> SignedMessage :
    return message

class HonestNode(NodeBase) :

    def __init__(self, coorindator):
        # coordinator provides the "permissioned" services
        self._coorindator = coorindator
        # codes to generate rsa key pair, not used yet
        # (self.pub_key, self.priv_key) = rsa.newkeys(512)

        self._nodeId = secrets.randbelow(2**64)
        self._txpool = TxPool()
        self._orphanpool = OrphanBlockPool()

        raise NotImplemented
        self._block_chain = BlockChain()

    @property
    def id(self) -> NodeId:
        return self._nodeId

    @property
    def main_chain(self):
        raise NotImplemented
        return self._block_chain.main_chain

    def round_action(self, ctx: Context) -> None :
        # check recieved blocks
        messages : List[Any] = ctx.received_messages
        txs : List[Tx] = []
        blocks : List[TBlock] = []

        for message in messages :
            if message.type == 0 :   # its a transaction
                if check_tx(message["value"]) :
                    txs.append(message["value"])
            elif message.type == 1 :   # its a block
                if not check_solution(message["value"]) :
                    continue
                elif message["value"].timestamp >= ctx.round :
                    continue
                else :
                    blocks.append(message["value"])

        for block in blocks :
            # check block type : extend main chain, extend alternative chain, orphan block
            ctx.broadcast(block)

            raise NotImplemented
            block_father = self_block_chain.find(block.pbhv)
            if block_father != None :
                self._block_chain.add_child(block_father, block)

            else :
                self._orphanpool.add(block)

        # check
        raise NotImplemented
